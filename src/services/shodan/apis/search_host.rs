/*
 * Shodan REST API Documentation
 *
 * To use the API you need to have an API key, which you can get for free by creating a Shodan account.      [CREATE A SHODAN ACCOUNT](https://account.shodan.io/register)  This documentation covers the raw APIs that are provided by Shodan, you should only have to use this if no library is available in your language that wraps the Shodan API in a developer-friendly way.
 *
 * The version of the OpenAPI document: 1.0.0
 *
 * Generated by: https://openapi-generator.tech
 */

use crate::services::shodan::apis::{configuration, ContentType, Error, ResponseContent};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for passing parameters to the method [`search_host`]
#[derive(Clone, Debug)]
pub struct SearchHostParams {
    /// To use the API you need to have an API key, which you can get for free by creating a Shodan account.
    pub key: String,
    /// Shodan search query. The provided string is used to search the database of banners in Shodan, with the additional option to provide filters inside the search query using a \"filter:value\" format. For example, the following search query would find Apache Web servers located in Germany: \"apache country:DE\".
    pub query: String,
    /// A comma-separated list of properties to get summary information on. Property names can also be in the format of \"property:count\", where \"count\" is the number of facets that will be returned for a property (i.e. \"country:100\" to get the top 100 countries for a search query). Visit the Shodan website's Facet Analysis page for an up-to-date list of available facets:
    pub facets: Option<String>,
    /// The page number to page through results 100 at a time (default: 1)
    pub page: Option<i32>,
}

/// struct for typed errors of method [`search_host`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchHostError {
    UnknownValue(serde_json::Value),
}

/// Search Shodan using the same query syntax as the website and use facets to get summary information for different properties.  ## **Requirements**  This method may use API query credits depending on usage. If any of the following criteria are met, your account will be deducted 1 query credit:  1. The search query contains a filter. 2. Accessing results past the 1st page using the \"page\". For every 100 results past the 1st page 1 query credit is deducted.
pub async fn search_host(
    configuration: &configuration::Configuration,
    params: SearchHostParams,
) -> Result<serde_json::Value, Error<SearchHostError>> {
    let uri_str = format!("{}/shodan/host/search", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("key", &params.key.to_string())]);
    req_builder = req_builder.query(&[("query", &params.query.to_string())]);
    if let Some(ref param_value) = params.facets {
        req_builder = req_builder.query(&[("facets", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `serde_json::Value`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `serde_json::Value`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SearchHostError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
